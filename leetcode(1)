
1.给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
int removeElement(int* nums, int numsSize, int val){
    //k记录不等于val的个数
    int k=0;
    for (int i=0;i<numsSize;i++){
        if (nums[i]!=val){
            nums[k] = nums[i];
            k++;
        }
    }
    return k;//新的顺序表的长度
}

2.给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

int removeDuplicates(int* nums, int numsSize)
{
    int np1 = 0, np2 = 0, dst = 0;
	while (np2 < numsSize)
	{
		nums[dst++] = nums[np1];
		while (nums[np1] == nums[np2])
		{
			np2++;
            if(np2==numsSize)
            {
                break;
            }
		}
		np1 = np2;
	}
	return dst;
}

3.给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。
说明:
初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。

void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) 
{
    if (m==0)
	{
		for (int i=0;i<n;i++)
		{
			nums1[i] = nums2[i];
		}
	}
	int end1 = m - 1;
	int end2 = n - 1;
	int dst = m+n-1;
	while (end1>=0||end2>=0) //循环条件
	{
		if (end1>=0&&end2>=0)
		{
			if (nums1[end1] > nums2[end2])
			{
				nums1[dst] = nums1[end1];
				end1--;
				dst--;
			}
			else
			{
				nums1[dst] = nums2[end2];
				end2--;
				dst--;
			}
		}else if (end1 >= 0 && end2 < 0)
		{
			nums1[dst] = nums1[end1];
			end1--;
			dst--;
		}else if (end2 >= 0 && end1 < 0)
		{
			nums1[dst] = nums2[end2];
			end2--;
			dst--;
		}
		
	}
}
4.原地右旋数组
void sortBack(int* arr, int left, int right)
{
	while (left < right)
	{
		int mid = 0;
		mid = arr[left];
		arr[left] = arr[right];
		arr[right] = mid;
		left++;
		right--;
	}
}
void rotate(int* nums, int numsSize, int k)
{
    k=k%numsSize;
	sortBack(nums, 0, numsSize-k-1);
	sortBack(nums, numsSize-k, numsSize-1);
	sortBack(nums, 0, numsSize - 1);
}

5.给定前序求中序
//c++递归，简单清晰
class Solution {
public:
    vector<int> res;
    vector<int> inorderTraversal(TreeNode* root) {
        if(root){
            inorderTraversal(root->left);
            res.push_back(root->val);
            inorderTraversal(root->right);
        }
        return res;
    }
};
6.leetcode 求二叉树深度
class Solution {
public:
    int maxDepth(TreeNode* root) {//简单递归即可求得深度 可以通过深度优先搜索或者广度优先搜索
        //深度优先遍历（DFS          //进行遍历时防止爆栈
        if(root==NULL){
            return 0;
        }
        else{
            int depthl=maxDepth(root->left);
            int depthr=maxDepth(root->right);
            if(depthl>depthr)
                return depthl+1;
            else
                return depthr+1;

        }
    }
};
7.平衡二叉树  这道题结合了二叉树高度进行求解
//平衡二叉树是左右子树高度差不超过一的二叉树
//那么就可以求左右子树高度 如果高度差超过1那么就说明不是
//我们就可以加一个变量进行求解
   struct TreeNode {
   int val;
   TreeNode *left;
   TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 };lass Solution {
public:
    int f=0;
    int dfs(TreeNode* root){
        if(root==NULL) return 0;
        int l=dfs(root->left);
        int r=dfs(root->right);
        if(abs(l-r)>1) f=1;
        return max(l,r)+1; 
    }
    bool isBalanced(TreeNode* root) {
        dfs(root);
        if(f) return false;
        else return true;
    }
};
8.二叉树层次遍历并输出
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

typedef struct Queue {
    int front;
    int rear;
    int len;
    struct TreeNode* elms[];
} Queue;

Queue *creatQueue(int len){
    Queue *q = malloc(sizeof(Queue) + len*sizeof(struct TreeNode*));
    q->len = len;
    q->front = 0;
    q->rear = 0;
    return q;
}

void enQueue(Queue *q, struct TreeNode* node){
    if(node == NULL) return;
    if((q->rear+1)%(q->len) == q->front) return;
    q->elms[q->rear] = node;
    q->rear = (q->rear+1)%(q->len);
}

struct TreeNode* outQueue(Queue *q){
    if(q->rear == q->front) return NULL;
    struct TreeNode* node = q->elms[q->front];
    q->front = (q->front+1)%(q->len);
    return node;
}

int maxDepth(struct TreeNode* root){
    if(root == NULL) return 0;
    int left=maxDepth(root->left), right=maxDepth(root->right);
    return 1 + (left>=right ? left : right);
}

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    // 计算树的最大深度
    *returnSize = maxDepth(root);

    // 以树的最大深度初始化结果的行数
    int **arrays = malloc(*returnSize * sizeof(int*));
    if(root==NULL) return arrays;// 空树请适可而止

    // 初始化保存每行的列数的数组
    *returnColumnSizes = malloc(*returnSize * sizeof(int));

    // 计算队列需要的最大长度
    // 即满二叉树最末层结点个数+1（因为用循环队列，所以+1）
    const int qMaxLen = (1 << (*returnSize-1)%(CHAR_BIT*sizeof(int))) +1;

    // 创建父队和子队，并把root入父队
    Queue *parentQ = creatQueue(qMaxLen), *childrenQ = creatQueue(qMaxLen);
    enQueue(parentQ, root);

    // level表示层数，遍历从最顶层开始，逐层向下
    // 初始i=1是为了结果的level行的列数正确
    for(int level=*returnSize-1, i=1; level > -1; --level){
        (*returnColumnSizes)[level] = i;
        arrays[level] = malloc(i * sizeof(int));

        // 父亲放到结果里，并且把孩子生出来
        for(i=0; parentQ->rear != parentQ->front; ++i){
            struct TreeNode* node = outQueue(parentQ);
            arrays[level][i] = node->val;
            if(node->left) enQueue(childrenQ, node->left);
            if(node->right) enQueue(childrenQ, node->right);
        }
        // 子队进化成父队
        // 下面的循环结束后会算出下一层父亲的个数
        // 并在下一次循环赋值(*returnColumnSizes)[level]
        for(i=0; childrenQ->rear != childrenQ->front; ++i)
            enQueue(parentQ, outQueue(childrenQ));
    }
    return arrays;
}


//okay
