linux


1.开关机命令
sync:将数据由内存同步到硬盘中
shutdown :关机指令
shutdown -h 10:十分钟后关机
shutdown -r 10:十分钟后重启


2.目录命令
pwd：查看当前位置
cd: 切换目录。..代表上一级。分相对路径和绝对路径
ls -a: 查看所有文件，包括隐藏
ll：详细信息
ls -ll：所有文件信息以及权限
mkdir：创建文件夹
mkdir -p:递归创建多级文件夹
rmdir ：删除目录（前提目录不为空）
rmdir -p:递归删除目录
cp：文件拷贝
rm -f:强制删除文件或目录。不会出现警告。
rm -r:递归删除目录，不出现警告。rm -rf 慎用
mv ：移动文件 
chmod 777 www:设置www的文件权限为所有都可读可写可查看。
tar -zxvf：解压命令
rz：xshell上传文件命令


3.文件内容查看命令
cat ：查看文件内容，从第一行开始。（空格代表翻页，回车代表下一行）
tac：在cat基础上倒过来，就是从最后一行开始看。
nl：显示时输出行号
more：一页一页的显示内容
/a:代表从文件中查找a字符串
?a:代表往上查找a字符串（n寻找下一个，N代表寻找上一个）

文件属性

首先，最前面有十个字母或-。第一个字母代表文件性质：d代表目录或文件夹，
l代表链接（相当于windows下的快捷方式）具体指向在最后面有->指向。
-代表是一个具体的文件。后面9个字母都是w、r、-。w为4，r为2，-为1.
所以一个文件最高权限就为4+2+1=7.前三个为所有者，中间三个为所属组，
后三个为其他用户。
接着，2代表当前文件有多少个，比如有些复制的也算在里面。
接着第一个www指所属主，第二个代表所属组。4096代表大小。
我们可以通过一些命令进行修改 如果我们需要进行某些操作的话
（su root切换管理员权限 ）
chomd 为其加减某项权限
chowd/chgrp修改文件所属 具体可以man查看

我们可以通过设置粘滞位chomd+t进行设置 防止别人修改自己的代码


编辑器vim
vim a.txt：当a.txt存在，即进入编辑模式。如果不存在，相当于创建了a.txt文件并进入编辑模式。
vim分三种模式：
命令模式（command mode）、
输入模式（insert mode）、
底线命令模式（Last line mode）。
第一种常见：dd删除当前行。
第二种常见按i键进入输入模式，即可编辑文本。
第三种常见：wq。保存退出。
基本操作：vim a.txt进入编辑模式，上下左右或者hjkl上下移动光标。
按i键进入编辑模式，编辑完成后esc退出编辑模式，：wq保存并退出vim。
常用：在底线命令模式下，/a向下查找a字符串。
?a向上查找a字符串。n代表查找下一个，N代表向上查找下一个。
快速移动光标：H：快速移动到第一行第一个字符、M：中间、L：最后一行。
快速移动光标：数字+空格（横着）、、数字+enter（竖着）。
显示行号：底线命令模式下：set：nu（常用）

make与makefile
make是一条命令,makefile是一个文件， 搭配使用可以完成项目的自动化构建。
makefile中的描述用于指导make程序如何完成工作；make根据makefile中的规则执行命令，
最后完成编译输出。
Makefile里面放的是依赖关系和依赖方法
当然项目也是需要被清理的，像clean这种，没有被第一个目标文件直接或间接关联，
那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。
即命令——“make clean”，以此来清除所有的目标文件，以便重编译。
但是一般我们这种clean的目标文件，我们将它设置为伪目标,
用 .PHONY 修饰,伪目标的特性是，总是被执行的。

进程方面1
linux中，每个进程都有自己的id号。
每一个进程都有自己的父进程。进程可以有两种存在方式，
前台和后台（退出xshell后还在运行，比如运行jar文件）。
ps：查看当前系统中正在执行的
ps：查看当前系统中正在执行的各种进程信息
-a: 显示所有进程信息
-u：以用户信息显示进程
-x：显示后台运行的参数
ps -aux |grep java :|叫管道符，在前面的基础上进行过滤的意思。grep抓取和java有关的进程
ps -ef|grep java :ef指查看父进程的信息（更推荐用树的方法 ）
pstree -pu
kill -9 强制杀死一个进程

进程方面2
首先什么是进程
进程是系统进行资源分配和调度的一个独立单位，进程包括程序段、数据和PCB
pcb是一个task–struct结构体 里面存储很多数据 比如
程序计数器 上下文数据
进程状态
3种基本状态：
就绪状态：进程获得了除处理机CPU之外的所有资源（可以有多个，排成就绪队列）
执行状态：进程的程序正在处理机上执行（单CPU中只有一个进程处于该状态）
阻塞状态：因发生某事件（如请求I/O，申请缓存空间等）而暂停执行的状态（也称为睡眠状态或等待状态）
进程方面3
pcb详细信息

PCB的内容
1、进程标识符
用于唯一标识一个进程，可分为2种，一种是内部标识符，
是进程的唯一序号，一种是外部标识符，由创建者提供名字
2、处理机状态
CPU处理进程的现场信息，包括通用寄存器、指令计数器、程序状态字PSW、用户堆栈指针等信息
3、进程调度信息
进程状态
进程优先级
进程调度的其它信息（如进程已等待CPU的时间、进程已执行的时间总和等）
事件（进程由执行状态变成阻塞状态的事件，即阻塞原因）
4、进程控制信息
程序和数据的地址
进程同步和通信机制（如消息队列，信号量等）
资源清单（列出进程在运行期间所需的全部资源）
链接指针（给出本进程所在队列的下一个进程的PCB的首地址）
pcb 通过线性方式、链接方式、索引方式这三种方式进行组织

进程控制方面

进程创建 进程创建被定义为通过父进程创建子进程的过程。
fork函数
函数原型：pid_t fork(void);
特点： 
1.fork函数调用一次，返回两次两次返回值得区别分别是子进程当中的返回值为0，
父进程当中的返回值为新建子进程的ID
（将ID返回给父进程的原因是没有函数可以使父进程得到子进程的ID,这样会便于管理）； 
2.子进程被创建出来后，子进程是父进程的副本
（子进程获得父进程数据空间，堆，栈的副本<一定注意是副本>）； 
3.父进程和子进程只共享正文段（.text）； 
4.由于fork之后经常跟随者exec(程序加载函数),所以现在很多操作系统的实现并不执行一个父进程的副本，
而是使用了写时拷贝（这些区域由父子进程所共享，而且内核将这些区域的访问权限设定为只读权限，
如果父进程和子进程中的任意一个区域试图被修改，则内核会为修改区域产生一个副本）。 
5.fork之后父进程和子进程的执行顺序是随机的，取决于内核所使用的调度算法。 

函数vfork  在对进程创建这部分进行学习的时候其实 vfork使用并不多
vfork函数也是创建进程，但是与fork函数不相同的是： 
1.vfork创建一个新进程，而新进程的目的是exec一个新程序； 
2.vfork并不将父进程的地址空间完全复制到子进程中； 
3.子进程在调用exec函数或者exit函数之前，子进程在父进程的空间中运行； 
4.vfork函数保证子进程先运行，在它调用exec或exit函数之后父进程才会被恢复运行。

进程终止
进程有多种正常终止方式和异常终止方式
正常终止方式 
1.在main函数内执行return 语句。它等效于调用exit; 
2.调用exit函数，exit函数由C库定义，其操作包含调用各种终止处理程序，关闭所有标准I/O流等。
3.调用_exit函数,exit函数和_exit函数的不用地方就是它为进程提供了一种无需终止运行终止处理程序或信号处理程序而终止的办法。 


异常终止暂时并未接触太多 等到以后学习到了再来更新这部分内容



僵尸进程和守护进程
简单来说 当子进程先于父进程退出并且父进程没有关注子进程这是子进程就会变成僵尸进程
当父进程先于子进程退出 子进程就会变成孤儿进程 也就是守护进程

进程等待
关于进程等待我们首先应该想到这两个函数，
wait和waitpid函数都是用来提供给父进程检测子进程的状态的
pid_t wait(int* status); 
其中，status参数是前面提到的父进程用来监测子进程退出状态的输出型参数
pid _t waitpid(pid_t pid,int *status,int options); 
pid为监测子进程的标识符； 
status:子进程的终止状态信息，如果不是空指针，
则终止进程的终止信息就存放在它所指向的单元内，不关心终止状态可以将status制成NULL; 
options:指定参数，默认情况下waitpid与wait做的事情都是一样的，为阻塞式监测子进程终止状态；
当options=WNOHANG时，此时为非阻塞方式，就是监测时如果子进程没有终止，调用者可以做其他事情，
另外还有两个参数分别为WCONTINUED和WUNTRACED
看看两个函数的区别
在一个子进程终止前，wait使调用者阻塞，而waitpid有一个选项可以使调用者不发生阻塞；
waitpid并不等待在其调用之后的第一个终止子进程，它有若干选项，并可以控制子进程
waitpid可以等待一个特定的进程，通过pid参数进行设定；
